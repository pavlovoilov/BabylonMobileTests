{
  "uid" : "c4f519c8-c718-4164-9e6d-156048e53c47",
  "name" : "AllureTests.test_powering",
  "title" : "Test powering",
  "time" : {
    "start" : 1409237391323,
    "stop" : 1409237392438,
    "duration" : 1115
  },
  "summary" : {
    "attachments" : 0,
    "steps" : 1
  },
  "failure" : {
    "message" : "URLError: <urlopen error [Errno 10061] No connection could be made because the target machine actively refused it>",
    "stackTrace" : "a = (<BabylonMobileTests.tests.babylon_allure_test.AllureTests testMethod=test_powering>,)\nkw = {}\n\n    @wraps(func)\n    def impl(*a, **kw):\n        with self:\n>           return func(*a, **kw)\n\nC:\\Python27\\lib\\site-packages\\allure\\common.py:49: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <BabylonMobileTests.tests.babylon_allure_test.AllureTests testMethod=test_powering>\n\n    @allure.step('Set up')\n    def setUp(self):\n        \"Setup for the test\"\n        desired_caps = {}\n        desired_caps['platformName'] = PLATFORM_NAME\n        desired_caps['platformVersion'] = PLATFORM_VERSION\n        desired_caps['deviceName'] = DEVICE_NAME\n    \n        # Returns abs path relative to this file and not cwd\n        desired_caps['app'] = os.path.abspath(os.path.join(os.path.dirname(__file__),APP_PATH))\n        desired_caps['appPackage'] = APP_PACKAGE\n>       self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)\n\nBaseTest.py:20: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <appium.webdriver.webdriver.WebDriver object at 0x03674E70>\ncommand_executor = 'http://localhost:4723/wd/hub'\ndesired_capabilities = {'app': 'C:\\\\PyCharmWS\\\\BabylonMobileTests\\\\apps\\\\alliantsStage-369.apk', 'appPackage': 'com.babylon', 'deviceName': '07092acf00d9cab0', 'platformName': 'Android', ...}\nbrowser_profile = None, proxy = None, keep_alive = False\n\n    def __init__(self, command_executor='http://127.0.0.1:4444/wd/hub',\n                 desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False):\n    \n>       super(WebDriver, self).__init__(command_executor, desired_capabilities, browser_profile, proxy, keep_alive)\n\nC:\\Python27\\lib\\site-packages\\appium\\webdriver\\webdriver.py:35: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <appium.webdriver.webdriver.WebDriver object at 0x03674E70>\ncommand_executor = 'http://localhost:4723/wd/hub'\ndesired_capabilities = {'app': 'C:\\\\PyCharmWS\\\\BabylonMobileTests\\\\apps\\\\alliantsStage-369.apk', 'appPackage': 'com.babylon', 'deviceName': '07092acf00d9cab0', 'platformName': 'Android', ...}\nbrowser_profile = None, proxy = None, keep_alive = False\n\n    def __init__(self, command_executor='http://127.0.0.1:4444/wd/hub',\n        desired_capabilities=None, browser_profile=None, proxy=None, keep_alive=False):\n        \"\"\"\n            Create a new driver that will issue commands using the wire protocol.\n    \n            :Args:\n             - command_executor - Either a command.CommandExecutor object or a string that specifies the URL of a remote server to send commands to.\n             - desired_capabilities - Dictionary holding predefined values for starting a browser\n             - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object.  Only used if Firefox is requested.\n            \"\"\"\n        if desired_capabilities is None:\n            raise WebDriverException(\"Desired Capabilities can't be None\")\n        if not isinstance(desired_capabilities, dict):\n            raise WebDriverException(\"Desired Capabilities must be a dictionary\")\n        if proxy is not None:\n            proxy.add_to_capabilities(desired_capabilities)\n        self.command_executor = command_executor\n        if type(self.command_executor) is bytes or isinstance(self.command_executor, str):\n            self.command_executor = RemoteConnection(command_executor, keep_alive=keep_alive)\n        self._is_remote = True\n        self.session_id = None\n        self.capabilities = {}\n        self.error_handler = ErrorHandler()\n        self.start_client()\n>       self.start_session(desired_capabilities, browser_profile)\n\nC:\\Python27\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:73: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <appium.webdriver.webdriver.WebDriver object at 0x03674E70>\ndesired_capabilities = {'app': 'C:\\\\PyCharmWS\\\\BabylonMobileTests\\\\apps\\\\alliantsStage-369.apk', 'appPackage': 'com.babylon', 'deviceName': '07092acf00d9cab0', 'platformName': 'Android', ...}\nbrowser_profile = None\n\n    def start_session(self, desired_capabilities, browser_profile=None):\n        \"\"\"\n            Creates a new session with the desired capabilities.\n    \n            :Args:\n             - browser_name - The name of the browser to request.\n             - version - Which browser version to request.\n             - platform - Which platform to request the browser on.\n             - javascript_enabled - Whether the new session should support JavaScript.\n             - browser_profile - A selenium.webdriver.firefox.firefox_profile.FirefoxProfile object. Only used if Firefox is requested.\n            \"\"\"\n        if browser_profile:\n            desired_capabilities['firefox_profile'] = browser_profile.encoded\n        response = self.execute(Command.NEW_SESSION, {\n>           'desiredCapabilities': desired_capabilities,\n        })\n\nC:\\Python27\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:121: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <appium.webdriver.webdriver.WebDriver object at 0x03674E70>\ndriver_command = 'newSession'\nparams = {'desiredCapabilities': {'app': 'C:\\\\PyCharmWS\\\\BabylonMobileTests\\\\apps\\\\alliantsStage-369.apk', 'appPackage': 'com.babylon', 'deviceName': '07092acf00d9cab0', 'platformName': 'Android', ...}}\n\n    def execute(self, driver_command, params=None):\n        \"\"\"\n            Sends a command to be executed by a command.CommandExecutor.\n    \n            :Args:\n             - driver_command: The name of the command to execute as a string.\n             - params: A dictionary of named parameters to send with the command.\n    \n            :Returns:\n              The command's JSON response loaded into a dictionary object.\n            \"\"\"\n        if self.session_id is not None:\n            if not params:\n                params = {'sessionId': self.session_id}\n            elif 'sessionId' not in params:\n                params['sessionId'] = self.session_id\n    \n        params = self._wrap_value(params)\n>       response = self.command_executor.execute(driver_command, params)\n\nC:\\Python27\\lib\\site-packages\\selenium\\webdriver\\remote\\webdriver.py:171: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.remote.remote_connection.RemoteConnection object at 0x03674FD0>\ncommand = 'newSession'\nparams = {'desiredCapabilities': {'app': 'C:\\\\PyCharmWS\\\\BabylonMobileTests\\\\apps\\\\alliantsStage-369.apk', 'appPackage': 'com.babylon', 'deviceName': '07092acf00d9cab0', 'platformName': 'Android', ...}}\n\n    def execute(self, command, params):\n        \"\"\"\n            Send a command to the remote server.\n    \n            Any path subtitutions required for the URL mapped to the command should be\n            included in the command parameters.\n    \n            :Args:\n             - command - A string specifying the command to execute.\n             - params - A dictionary of named parameters to send with the command as\n               its JSON payload.\n            \"\"\"\n        command_info = self._commands[command]\n        assert command_info is not None, 'Unrecognised command %s' % command\n        data = utils.dump_json(params)\n        path = string.Template(command_info[1]).substitute(params)\n        url = '%s%s' % (self._url, path)\n>       return self._request(command_info[0], url, body=data)\n\nC:\\Python27\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py:347: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <selenium.webdriver.remote.remote_connection.RemoteConnection object at 0x03674FD0>\nmethod = 'POST', url = 'http://127.0.0.1:4723/wd/hub/session'\nbody = '{\"desiredCapabilities\": {\"platformVersion\": \"4.4\", \"deviceName\": \"07092acf00d9cab0\", \"app\": \"C:\\\\\\\\PyCharmWS\\\\\\\\BabylonMobileTests\\\\\\\\apps\\\\\\\\alliantsStage-369.apk\", \"platformName\": \"Android\", \"appPackage\": \"com.babylon\"}}'\n\n    def _request(self, method, url, body=None):\n        \"\"\"\n            Send an HTTP request to the remote server.\n    \n            :Args:\n             - method - A string for the HTTP method to send the request with.\n             - url - A string for the URL to send the request to.\n             - body - A string for request body. Ignored unless method is POST or PUT.\n    \n            :Returns:\n              A dictionary with the server's parsed JSON response.\n            \"\"\"\n        LOGGER.debug('%s %s %s' % (method, url, body))\n    \n        parsed_url = parse.urlparse(url)\n    \n        if self.keep_alive:\n            headers = {\"Connection\": 'keep-alive', method: parsed_url.path,\n                       \"User-Agent\": \"Python http auth\",\n                       \"Content-type\": \"application/json;charset=\\\"UTF-8\\\"\",\n                       \"Accept\": \"application/json\"}\n            if parsed_url.username:\n                auth = base64.standard_b64encode('%s:%s' %\n                       (parsed_url.username, parsed_url.password)).replace('\\n', '')\n                headers[\"Authorization\"] = \"Basic %s\" % auth\n            if body and method != 'POST' and method != 'PUT':\n                body = None\n            try:\n                self._conn.request(method, parsed_url.path, body, headers)\n                resp = self._conn.getresponse()\n            except httplib.HTTPException:\n                self._conn.close()\n                raise\n    \n            statuscode = resp.status\n        else:\n            password_manager = None\n            if parsed_url.username:\n                netloc = parsed_url.hostname\n                if parsed_url.port:\n                    netloc += \":%s\" % parsed_url.port\n                cleaned_url = parse.urlunparse((parsed_url.scheme,\n                                                   netloc,\n                                                   parsed_url.path,\n                                                   parsed_url.params,\n                                                   parsed_url.query,\n                                                   parsed_url.fragment))\n                password_manager = url_request.HTTPPasswordMgrWithDefaultRealm()\n                password_manager.add_password(None,\n                                              \"%s://%s\" % (parsed_url.scheme, netloc),\n                                              parsed_url.username,\n                                              parsed_url.password)\n                request = Request(cleaned_url, data=body.encode('utf-8'), method=method)\n            else:\n                request = Request(url, data=body.encode('utf-8'), method=method)\n    \n            request.add_header('Accept', 'application/json')\n            request.add_header('Content-Type', 'application/json;charset=UTF-8')\n    \n            if password_manager:\n                opener = url_request.build_opener(url_request.HTTPRedirectHandler(),\n                                                  HttpErrorHandler(),\n                                                  url_request.HTTPBasicAuthHandler(password_manager))\n            else:\n                opener = url_request.build_opener(url_request.HTTPRedirectHandler(),\n                                                  HttpErrorHandler())\n>           resp = opener.open(request)\n\nC:\\Python27\\lib\\site-packages\\selenium\\webdriver\\remote\\remote_connection.py:415: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib2.OpenerDirector instance at 0x0367F5A8>\nfullurl = <selenium.webdriver.remote.remote_connection.Request instance at 0x0367F418>\ndata = None, timeout = <object object at 0x01D51578>\n\n    def open(self, fullurl, data=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):\n        # accept a URL or a Request object\n        if isinstance(fullurl, basestring):\n            req = Request(fullurl, data)\n        else:\n            req = fullurl\n            if data is not None:\n                req.add_data(data)\n    \n        req.timeout = timeout\n        protocol = req.get_type()\n    \n        # pre-process request\n        meth_name = protocol+\"_request\"\n        for processor in self.process_request.get(protocol, []):\n            meth = getattr(processor, meth_name)\n            req = meth(req)\n    \n>       response = self._open(req, data)\n\nC:\\Python27\\lib\\urllib2.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib2.OpenerDirector instance at 0x0367F5A8>\nreq = <selenium.webdriver.remote.remote_connection.Request instance at 0x0367F418>\ndata = None\n\n    def _open(self, req, data=None):\n        result = self._call_chain(self.handle_open, 'default',\n                                  'default_open', req)\n        if result:\n            return result\n    \n        protocol = req.get_type()\n        result = self._call_chain(self.handle_open, protocol, protocol +\n>                                 '_open', req)\n\nC:\\Python27\\lib\\urllib2.py:422: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib2.OpenerDirector instance at 0x0367F5A8>\nchain = {'file': [<urllib2.FileHandler instance at 0x0367FE40>], 'ftp': [<urllib2.FTPHandler instance at 0x0367FE18>], 'http': [<urllib2.HTTPHandler instance at 0x0367FDF0>], 'https': [<urllib2.HTTPSHandler instance at 0x0367FE90>], ...}\nkind = 'http', meth_name = 'http_open'\nargs = (<selenium.webdriver.remote.remote_connection.Request instance at 0x0367F418>,)\nhandlers = [<urllib2.HTTPHandler instance at 0x0367FDF0>]\nhandler = <urllib2.HTTPHandler instance at 0x0367FDF0>\nfunc = <bound method HTTPHandler.http_open of <urllib2.HTTPHandler instance at 0x0367FDF0>>\n\n    def _call_chain(self, chain, kind, meth_name, *args):\n        # Handlers raise an exception if no one else should try to handle\n        # the request, or return None if they can't but another handler\n        # could.  Otherwise, they return the response.\n        handlers = chain.get(kind, ())\n        for handler in handlers:\n            func = getattr(handler, meth_name)\n    \n>           result = func(*args)\n\nC:\\Python27\\lib\\urllib2.py:382: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib2.HTTPHandler instance at 0x0367FDF0>\nreq = <selenium.webdriver.remote.remote_connection.Request instance at 0x0367F418>\n\n    def http_open(self, req):\n>       return self.do_open(httplib.HTTPConnection, req)\n\nC:\\Python27\\lib\\urllib2.py:1214: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <urllib2.HTTPHandler instance at 0x0367FDF0>\nhttp_class = <class httplib.HTTPConnection at 0x03559D88>\nreq = <selenium.webdriver.remote.remote_connection.Request instance at 0x0367F418>\n\n    def do_open(self, http_class, req):\n        \"\"\"Return an addinfourl object for the request, using http_class.\n    \n            http_class must implement the HTTPConnection API from httplib.\n            The addinfourl return value is a file-like object.  It also\n            has methods and attributes including:\n                - info(): return a mimetools.Message object for the headers\n                - geturl(): return the original request URL\n                - code: HTTP status code\n            \"\"\"\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n    \n        h = http_class(host, timeout=req.timeout) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n        except socket.error, err: # XXX what error?\n            h.close()\n>           raise URLError(err)\nE           URLError: <urlopen error [Errno 10061] No connection could be made because the target machine actively refused it>\n\nC:\\Python27\\lib\\urllib2.py:1184: URLError"
  },
  "description" : null,
  "severity" : "NORMAL",
  "status" : "FAILED",
  "steps" : [ {
    "name" : "Set up",
    "title" : "Set up",
    "time" : {
      "start" : 1409237391325,
      "stop" : 1409237392328,
      "duration" : 1003
    },
    "summary" : {
      "attachments" : 0,
      "steps" : 0
    },
    "status" : "FAILED",
    "attachments" : [ ],
    "steps" : [ ]
  } ],
  "attachments" : [ ],
  "labels" : [ {
    "name" : "feature",
    "value" : "Without feature"
  }, {
    "name" : "story",
    "value" : "Without story"
  } ],
  "parameters" : [ ]
}